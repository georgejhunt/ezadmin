#!/bin/bash -x
# reminder of what it takes to create a bootable mbr/efi tinycore appliance
# most of this based on James Cameron's mktinycorxo at
# http://dev.laptop.org/git/users/quozl/mktinycorexo

COLOUR="yes"
ARCH="x86"
#ARCH="x86_64"
#PARTITION="efi"
PARTITION="mbr"

FC_VER="20"
#FC_ARCH="i386"
FC_ARCH="x86_64"
FC_URL="mirrors.usc.edu/pub/linux/distributions/fedora/linux/releases/${FC_VER}/Fedora/${FC_ARCH}/os/isolinux/"

# upstream versions, tiny core linux
CORE_VERSION=5.x

# tinycore initramfs name
#CORE_INITRD_X86=core
CORE_INITRD_X86=corepure64
#CORE_KERNEL_X86=vmlinuz
CORE_KERNEL_X86=vmlinuz64
CACHE=no

# check that we have the needed tools
for x in xzcat wget gdisk extlinux grub2-install mke2fs e2label mkdosfs; do
    which $x
    if [ $? -ne 0 ] ; then
        echo -e "\\0033[1;34m"
        echo "Please install $x and run the script again"
        echo -en "\\0033[0;39m"
        exit 1
    fi
done

# verify that there is the correct USB drive installed
blkid
echo  "\nEnter the device to destroy, and repartition (without partition #)"
echo -n "i.e. /dev/sdb. (or hit ctl-c to abort):"
read dev

# make sure our device is unmounted
line=`mount |grep $dev | gawk '{print $1}'`
while [ $? -eq 0 && "$line" != ""]; do
	echo $line
	umount $line
	line=`mount |grep $dev | gawk '{print $1}'`
done

# build the cache
mkdir -p cache
mkdir -p cache/boot
mkdir -p cache/TCZs_${ARCH}/tce/optional
mkdir -p cache/target/syslinux

function p_error {
    if [ "$COLOUR" = "yes" ]; then
        echo -e "\e[1;91m$1\e[0;39m"
    else
        echo "$1"
    fi
}

function p_warning {
    if [ "$COLOUR" = "yes" ]; then
        echo -e "\e[1;93m$1\e[0;39m"
    else
        echo "$1"
    fi
}

function p_informational {
    if [ "$COLOUR" = "yes" ]; then
        echo -e "\e[1;92m$1\e[0;39m"
    else
        echo "$1"
    fi
}

function p_begin {
    if [ "$COLOUR" = "yes" ]; then
        echo -ne "\e[1;96m$1\e[0;39m"
    else
        echo -n "$1"
    fi
}

function p_end {
    if [ "$COLOUR" = "yes" ]; then
        echo -e "\e[1;92m$1\e[0;39m"
    else
        echo "$1"
    fi
}


# if the non-data is cleared it might compress better
dd if=/dev/zero of=$dev bs=1M count=100
#dd if=/dev/zero of=$dev bs=1M count=4000

if [ $PARTITION == "mbr" ]; then
cat << EOF | /usr/sbin/fdisk ${dev}
d

d

d

d

n
p
1
8064
+2020M
t
83
a

w
EOF
fi

if [ $PARTITION == "efi" ]; then
cat << EOF | /usr/sbin/gdisk ${dev}
d

d

d

d

n
p
1
8064
+2020M
t
83
a

w
EOF
fi

partprobe $dev
mke2fs -t ext2 -L tinycore "${dev}1"
mkdir -p /mnt/tinycore

mount ${dev}1 /mnt/tinycore
mkdir -p /mnt/tinycore/boot
 
function get_initrd {
    flags="-q -c -P cache/boot/"
    path=$1/$2
    file=$3
    checksum=$file.md5.txt

    if [ ! -f cache/$file ]; then
        p_begin "Downloading $file ... "
        wget $flags $path/$file
        p_end "ok"
        return
    fi

    if [ $CACHE = no ]; then
        p_begin "Checking if $file is up to date ... "
        wget $flags $path/$checksum
        if [ "$(cat cache/$checksum | cut -f 1 -d ' ')" \
            != "$(md5sum cache/$file | cut -f 1 -d ' ')" ]; then
            p_end "no"
            rm -f cache/$file
            p_begin "Downloading $file ... "
            wget $flags $path/$file
        fi
        p_end "ok"
        rm -f cache/$checksum
    fi
}

get_initrd \
    http://repo.tinycorelinux.net/${CORE_VERSION} \
    ${ARCH}/release/distribution_files \
    ${CORE_INITRD_X86}.gz
get_initrd \
    http://repo.tinycorelinux.net/${CORE_VERSION} \
    ${ARCH}/release/distribution_files \
    ${CORE_KERNEL_X86}


    # download tiny core extension
    cat <<EOF > cache/TCZs_${ARCH}/tce/onboot.lst
appbrowser-cli.tcz
avahi.tcz
dosfstools.tcz
dbus.tcz
expat2.tcz
gcc_libs.tcz
gdisk.tcz
glib2.tcz
gzip.tcz
libdaemon.tcz
libavahi.tcz
libffi.tcz
libnl.tcz
libusb.tcz
nano.tcz
ncurses-common.tcz
ncurses.tcz
ncurses-utils.tcz
nss-mdns.tcz
openssh.tcz
openssl-1.0.0.tcz
parted.tcz
readline.tcz
rsync.tcz
syslinux.tcz
tar.tcz
tree.tcz
usb-utils.tcz
wget.tcz
xz.tcz
EOF

p_begin "Checking ${ARCH} extensions ... "
base=http://repo.tinycorelinux.net/${CORE_VERSION}
cache=cache/TCZs_${ARCH}/tce/optional/
flags="-q -c -P $cache"
for file in $(<cache/TCZs_${ARCH}/tce/onboot.lst); do
    if [ ! -f cache/TCZs_${ARCH}/tce/optional/$file ]; then
        wget ${flags} ${base}/${ARCH}/tcz/$file  \
        wget ${flags} ${base}/${ARCH}/tcz/$file.md5.txt  \
        wget ${flags} ${base}/${ARCH}/tcz/$file.dep  \
        p_end "got $file"
    else
        if [ $CACHE = no ]; then
            rm -f $cache/$file.md5.txt
            wget ${flags} ${base}/${ARCH}/tcz/$file.md5.txt  
            if [ "$(cat $cache/$file.md5.txt | cut -f 1 -d ' ')" \
                != "$(md5sum $cache/$file | cut -f 1 -d ' ')" ]; then
                rm -f cache/TCZs_${ARCH}/tce/optional/$file{,.dep}
                wget ${flags} ${base}/${ARCH}/tcz/$file  \
                wget ${flags} ${base}/${ARCH}/tcz/$file.dep \
                p_end "updated $file"
            fi
        fi
    fi
done
p_end "ok"

mkdir -p /mnt/tinycore/boot/extlinux
extlinux --install /mnt/tinycore/boot/extlinux
rsync cache/boot/* /mnt/tinycore/boot
rsync /boot/extlinux/* /mnt/tinycore/boot/extlinux
rsync -r cache/TCZs_${ARCH}/tce /mnt/tinycore/
if [ "$ARCH" == "x86" ]; then
	cp extlinux.conf /mnt/tinycore/boot/extlinux
else
	cp extlinux64.conf /mnt/tinycore/boot/extlinux/extlinux.conf
fi

# copy the mbr loader to the first block of the stick
dd if=/usr/share/syslinux/mbr.bin of=${dev} bs=440 count=1 


function get_rootfs {
    # rootfs is in a squashfs in the /boot/LiveOS folder of boot.iso
    FC_ARCH=$1
    mkdir -p cache/target/${FC_VER}/${FC_ARCH}
    flags="-q -c "
    file="boot.iso"
    FC_URL="mirrors.usc.edu/pub/linux/distributions/fedora/linux/releases/${FC_VER}/Fedora/${FC_ARCH}/os/images/"
    path=${FC_URL}$file
    if [ ! -f cache/target/$FC_VER/$FC_ARCH/rootfs.tgz ]; then
        p_begin "Downloading $file ... "
	pushd cache/target/$FC_VER/$FC_ARCH
        	wget $flags $path
		# the downloaded file is iso9660 format
		mkdir -p bootiso
		mount  boot.iso bootiso 
		cp -f bootiso/LiveOS/squashfs.img squashfs.img
		cp -f bootiso/isolinux/vmlinuz .
		cp -f bootiso/isolinux/initrd.img .
		cp -f bootiso/isolinux/isolinux.cfg .
		unsquashfs -f squashfs.img
		cd squashfs-root
		# the rootfs is ext4 format as a single file
		mkdir temp
		mount LiveOS/rootfs.img ./temp
		cd temp
		tar Jcf ../../rootfs.tgz *
		cd ../..
		umount ./squashfs-root/temp
		umount ./bootiso
		rmdir  bootiso
		rm -rf squashfs-root 
		rm -f squashfs.img 
		rm boot.iso
	popd
        p_end "ok"
        return
    fi

}

get_rootfs i386

get_rootfs x86_64

mkdir -p /mnt/tinycore/target/i386
mkdir -p /mnt/tinycore/target/x86_64
cp -r cache/target/${FC_VER}/i386/* /mnt/tinycore/target/i386
cp -r cache/target/${FC_VER}/x86_64/* /mnt/tinycore/target/x86_64
cp loadOS /mnt/tinycore/target
